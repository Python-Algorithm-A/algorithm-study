# 삽입 정렬과 퀵 정렬

## 삽입 정렬

- 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘
- 카드를 정렬하는 것과 비슷하다고 생각하면 됨.
- 배열을 정렬되지 않은 부분과 정렬된 부분으로 쪼개서 정렬되지 않은 부분의 요소를 정렬된 부분에 삽입.
- 반복마다 정렬되지 않는 부분의 첫번째 항목이 제거되어 정확한 위치에 삽입됨.
- 배열이 길어질 수록 효율이 떨어짐.
- 구현이 간단함.

### 구현

1. 맨 처음 요소를 정렬된 배열로 가정. 그 다음 요소를 ***키*** 값으로 정한다.
2. 정렬된 배열을 순회하면서 키 값보다 요소가 더 큰 경우 해당 요소의 위치를 오른쪽으로 한칸 옮긴다.
3. 키 값보다 더 작은 요소가 나올 경우 해당 요소 오른쪽에 키 값을 넣는다.
4. 정렬된 배열의 길이가 원래 배열과 같아질 때 까지 반복한다.

<img src="./insertion_sort.png"></img>

### 최선의 경우

- 이미 정렬된 배열일 경우.
- $O(n)$

### 최악의 경우

- 역순으로 정렬된 배열일 경우
- $O(n^2)$

## 퀵 정렬

- 분할 정복 알고리즘 중 하나.

### 과정

1. 리스트 안에 있는 한 요소를 선택. 이를 피벗(pivot) 이라고 한다. → pivot 고르는 방법마다 효율이 다름.
2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로, 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다.
3. 왼쪽 요소와 오른쪽 요소에서 다시 피벗을 정하고 (분할정복) 2번의 과정을 다시 수행한다.
4. 분할된 리스트의 크기가 0이나 1이 될 때 까지 반복한다. (분할이 불가능할 때 까지 반복한다.)

### 구현

1. 피벗값 지정. (예시에서는 첫번째 요소)
2. low 값과 high값 지정 (피벗 다음요소와 맨 끝 요소)
3. low는 피벗 값보다 큰 요소를 발견할 때 까지 이동, high는 피벗 값 보다 작은 요소를 발견할 때 까지 이동.
4. 둘다 발견 시 두 요소를 스왑하고 high 와 low가 엇갈릴 때 까지 3번을 실행
5. 엇갈렸을 때는 low 밑에는 피벗보다 작은 요소들이, high 위에는 피벗보다 큰 요소들만 있음.
6. 그럼 high와 pivot 값을 스왑.
7. pivot 왼쪽과 오른쪽에 같은 작업을 반복.
<img src="./quick_sort.png"></img>
<img src="./quick_sort2.png"></img>

### 특징

- 장점
    - 속도가 빠르다. $O(nlog_2n)$
    - 추가적인 메모리 공간이 필요하지 않는다.
- 단점
    - 정렬된 리스트에서는 오히려 수행시간이 많이 걸린다.
- 퀵 정렬의 불균형 분할을 방지하기 위해 피벗을 선택할 때 더욱 리스트를 균등하게 분할할 수 있는 데이터를 선택해야한다. (보통 리스트의 중간값을 피벗으로 선택한다) ⇒ 피벗보다 작은 배열과 큰 배열의 크기 차이가 큰 경우.
    - 불균형 분할은 이미 정렬되어있는 배열에 퀵소트를 실행할 경우에 크게 나타난다.
<br></br>
<img src="./quick_sort_unbalanced_partition.png"></img>
